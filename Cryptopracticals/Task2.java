package Cryptopracticals;

/**
 * @author vemvmacpro
 * This is for Practical 2 + 3 / task 2 and called BCH 10,6 and error checker
 */


public class Task2 extends javax.swing.JFrame {
    

    /**
     *  Creates new form NewJFrame and I renamed to Task 2
     */
    public Task2() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jTextField1 = new javax.swing.JTextField();
        jButton2 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setFont(new java.awt.Font("Lucida Grande", 0, 20)); // NOI18N
        jLabel1.setText("Error Correction Code");

        jButton1.setText("check");
        jButton1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jButton1MouseClicked(evt);
            }
        });

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        jButton2.setText("clear");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(31, 31, 31)
                                .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 184, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(16, 16, 16)
                                .addComponent(jLabel1)))
                        .addGap(18, 18, 18))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(jButton1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jButton2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(74, 74, 74)))
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 199, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(15, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(117, 117, 117)
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(31, 31, 31)
                        .addComponent(jButton1)
                        .addGap(33, 33, 33)
                        .addComponent(jButton2))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(25, 25, 25)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 356, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(26, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    // This negates a number in terms of modularity and returns the negative 
    // of the modulated number.
    public int negate(int a, int mod)
    {
   
        int temporary = -a % mod;
         
        if(temporary>=0) { 
        } else {
            temporary+=mod;
        }
        
        return temporary;
    }
    
    // Regarding to modular arithmetic, this will return the inverse of the number, 
    // all of this is from the lecture 2 slide using Euclidean Algorithm
    
    public int inverse(int a, int modulo) 
    { 
        
    int t = 0; 
    int newt = 1; 
    int r = modulo; 
    int newr = a;    
    int q, temporary;  

    if (newr != 0) {
            do {
                q = r / newr; // integer division  
                temporary = newt; // remember newt is put into a temporary 
                newt = t - q * newt;
                t = temporary;
                temporary = newr; // remember newr is put into a temporary 
                newr = r - q * newr;
                r = temporary;
            } while (newr != 0);
        } 
    
    if (r <= 1) {
            if (t < 0) t = t + modulo; // change to positive 
            return t;
        } else {
            return -1; // This is not invertible 
        }
    
    }


     // Regarding to the modular arithmetic this will return the square root 
     
    static int squareRoot(int n, int mod) 
    {
        n %= mod;

        // check all numbers by 1 by 1 from 2 to p-1
        
        int x = 1;
        while (x < mod) {
            if ((x * x) % mod != n) {
                x++;
            } else {
                return x;
            }
        }
        return -1;
    } 

    
    // TESTS for example: 
    //The test below is an example that should output
    // input(3745195876) output(3745195876) no_error
    // input(3945195876) output(3745195876) single_err(i=2,a=2,syn(2,4,8,5))
    // input(3715195076) output(3745195876) double_err(i=8,a=3,j=3,b=8,syn(0,4,0,3),pqr(5,0,10))
    // input(1115195876) output( ?? ) morethan2_no_sqrt(syn(0,10,2,1),pqr(1,2,5))
    // This input 3121195876 has more than 2 errors - extra testing

 
     // This encodes a syndrome for BCH 10,6
   
    private int[] encodeSyndrome(int[] d, int mod)
    {
        int [] encoding_array = new int[10];
        
        // All of this is part of from the worksheet 2/practical 2 that we had 
        // to implement so array[0] is D7, array[1] is d8, array[2] is d9 and 
        // array[3] is d10 and calculated from mod 11. 
        
            encoding_array[0]= (4 * d[0] +
                  10 * d[1] + 
                   9 * d[2] +
                   2 * d[3] +
                   d[4]     +
                   7 * d[5]
                   ) % mod;

            encoding_array[1]= (7 * d[0] +
                   8 * d[1] + 
                   7 * d[2] +
                   d[3]     +
                   9 * d[4] +
                   6 * d[5]
                   ) % mod;

            
            encoding_array[2]= (9 * d[0] +
                   d[1]     + 
                   7 * d[2] +
                   8 * d[3] +
                   7 * d[4] +
                   7 * d[5]
                   ) % mod;

            
            encoding_array[3] =(d[0]     +
                    2 * d[1] + 
                    9 * d[2] +
                   10 * d[3] +
                    4 * d[4] +
                    d[5]
                    ) % mod;

           return encoding_array;

    }

    // This decodes a syndrome for BCH 10,6 and returns an array of the decoded syndrome
    
    private int[] decodeSyndrome(int[] d, int mod)
    {
            int [] decoding_array = new int[10];

            // This is s1 = (d1+....d10) mod 11
            int i=0;
        while (i<10) {
            decoding_array[0] += d[i];
            i++;
        }
        decoding_array[0] %= mod;

            // This is s2 = (d1+2*d2+3....+10*d10) mod 11
            decoding_array[1] = (d[0]+2 *
                    d[1]+3 *
                    d[2]+4 *
                    d[3]+5 *
                    d[4]+6 *
                    d[5]+7 *
                    d[6]+8 *
                    d[7]+9 *
                    d[8]+10 *
                    d[9])%mod;   

            // This is s3 = (d1+4*d2....+4*d9+d10) mod 11

            decoding_array[2]=(d[0] + 4 *
                    d[1] + 9 *
                    d[2] + 5 *
                    d[3] + 3 *
                    d[4] + 3 *
                    d[5] + 5 *
                    d[6] + 9 *
                    d[7] + 4 *
                    d[8] +
                    d[9]) % mod;

            // This is  s4 = (d1+8*d2.....+3*d9+10*d10) mod 11

            decoding_array[3]=(d[0] + 8 *
                    d[1] + 5 *
                    d[2] + 9 *
                    d[3] + 4 *
                    d[4] + 7 *
                    d[5] + 2 *
                    d[6] + 6 *
                    d[7] + 3 *
                    d[8] + 10 *
                    d[9]) % mod;   


            return decoding_array;
    }

    //This is a function for determining A using decoded syndromes 
    //and returns the proper magnitude/calculation of b.
    
    
    private int calculatingA(int[]syndrome, int b, int mod)
    {
        int outcome = syndrome[0] - b;

        if (outcome >= 0) {
            return outcome;
        }
        outcome = negate(~outcome+1,mod);

        return outcome;
    }


    //This returns CalculatingB based on syndromes and corrects the i/j values
    //Also calculates b(magnitude) for the 2nd error found in BCH 10,6.
   
    private int calculatingB(int[]syndrome, int i, int j, int mod)
    {
        int temporary = i-j;
        int outcome;

        if (temporary >= 0) {
            outcome = (negate(~(i*syndrome[0]-syndrome[1])+1,mod) * inverse(temporary,mod))%mod;
            if(outcome < 0)
                outcome = negate(~outcome+1,mod);
        } else {
            temporary = negate(~temporary+1,mod);
            outcome = (negate(~(i*syndrome[0]-syndrome[1])+1,mod) * inverse(temporary,mod))%mod;
            if(outcome < 0)
                outcome = negate(~outcome+1,mod);
        }


        return outcome;
    }


    
     // This function is for calculating I(position) 
     
    private int calculatingI(int p, int q, int r, int mod)
    {
        int newQ = ~q+1;
        int z = ((q*q) - (4*p*r))%mod;

        if (z >= 0) {
        } else {
            z = negate(~z+1,mod);
        }

        int temporary = squareRoot(z,mod);
        int x = (newQ + temporary)%mod;
        int y = (2*p)%11;

        int outcome = (negate(~x+1,mod) * inverse(y,mod))%mod;

        if (outcome >= 0) {
            return outcome;
        }
        outcome = negate(~outcome+1,mod);

        return outcome;
    }


    // This function is for calculating J(position)
    
    private int calculatingJ(int p, int q, int r, int mod)
    {
        int newQ = ~q+1;
        int z = ((q*q) - (4*p*r))%mod;

        if (z >= 0) {
        } else {
            z = negate(~z+1,mod);
        }

        int temporary = squareRoot(z,mod);
        int x = (newQ - temporary)%mod;
        int y = (2*p)%mod;

        int outcome = (negate(~x+1,mod) * inverse(y,mod))%mod;

        if (outcome >= 0) {
            return outcome;
        }
        outcome = negate(~outcome+1,mod);

        return outcome;
    }
    
    
    //This helps it clear the text fields and text area
    
    private void clear_user_interface()
    {
        jTextField1.setText("");
        jTextArea1.setText("");
    }

    
    // This will process the BCH code and determine the errors
    private void jButton1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jButton1MouseClicked
                
        int[] d = new int[10];
        int[] e;
        int[] syndrome;
        long out; 
        int variable_i;
        int variable_a;
        int variable_j;
        int variable_b;
        int p,q,r;
        int square_root;

        String s;
        
        
        s = jTextField1.getText();
        
        // The length needs to be valid for the BCH 10,6 if it's 10 chars long
        if(s.length() != 10)
        {
            jTextArea1.setText("Please enter a 10 digit number"); 
            return; 
        }

        int i = 0;
        while (i < 10) {
            d[i] = Integer.parseInt(String.valueOf(s.charAt(i)));
            i++;
        }

        // This will produce a decoded/encoded form of our syndromes 
        e = encodeSyndrome(d,11);
        syndrome = decodeSyndrome(d,11);


        // When all decoded syndromes are clear, this will produce a no error
        if(syndrome[0]+syndrome[1]+syndrome[2]+syndrome[3]==0)
        {
            out = Long.parseLong(s);
            jTextArea1.setText(" The input is:"+d[0]+d[1]+d[2]+d[3]+d[4]+d[5]+
                        " Please check:"+d[6]+d[7]+d[8]+d[9] + 
                        "\n The output is: "+ out+
                        "\n"+" The encoded syndromes: "+ e[0]+e[1]+e[2]+e[3] +"\n"+ 
                        "The decoded syndromes: "+ syndrome[0]+" "+syndrome[1]+" "+syndrome[2]+" "+syndrome[3]+" "+
                        "\n\n This has no_error");
        }
        
        
        else
        {

            // This will Calculate the p q and r 
            p = (syndrome[1]*syndrome[1]-syndrome[0]*syndrome[2])%11;
            q = (syndrome[0]*syndrome[3]-syndrome[1]*syndrome[2])%11;
            r = (syndrome[2]*syndrome[2]-syndrome[1]*syndrome[3])%11;
            if (p >= 0) {
            } else {
                p = negate(~p+1,11);
            }
            if (q >= 0) {
            } else {
                q = negate(~q+1,11);
            }
            if (r >= 0) {
            } else {
                r = negate(~r+1,11);
            }

            // This will get square root under the modulo 11
            square_root = ((q*q)-4*p*r)%11;
            if (square_root >= 0) {
            } else {
                square_root = negate(~square_root+1,11);
            }
            square_root = squareRoot(square_root, 11);

            // This will initialise the I J B and A for the error correction 
            variable_i = calculatingI(p,q,r,11);
            variable_j = calculatingJ(p,q,r,11);
            variable_b = calculatingB(syndrome, variable_i, variable_j,11);
            variable_a = calculatingA(syndrome, variable_b,11);

            // This will cacluate if only one error exists
            if((p == 0 && q == 0 && r == 0) && 
               (variable_i != 0 && variable_j != 0) &&
               (syndrome[1]/syndrome[0]) != 0
              )
            {

                variable_i = syndrome[1]/syndrome[0];
                variable_a = syndrome[0];

                int[] temporary_out = new int[10];

                int m = 0;
                while (m < 10) {
                    temporary_out[m] = d[m];
                    if (m != variable_i - 1) {
                    } else {
                        temporary_out[m] = (temporary_out[m] - variable_a)%11;
                        if (temporary_out[m] >= 0) {
                        } else {
                            temporary_out[m] = negate(~temporary_out[m]+1,11);
                        }
                    }
                    m++;
                }
                //print statements for the single error 
                jTextArea1.setText("The input is:"+d[0]+d[1]+d[2]+d[3]+d[4]+d[5]+
                      " Please check:"+d[6]+d[7]+d[8]+d[9] + "\n"+
                      "output:"+temporary_out[0]+temporary_out[1]+temporary_out[2]+temporary_out[3]+temporary_out[4]+temporary_out[5]+temporary_out[6]+temporary_out[7]+temporary_out[8]+temporary_out[9]+
                      "\n This has a single_err(i=" + variable_i + ",a="+variable_a+",syn("+syndrome[0]+","+syndrome[1]+","+syndrome[2]+","+syndrome[3]+"))");


            }
            
            // This will be a double error or more than 2 errors
            else
            {   
                // temporary values used to verify a/b
                int verify_a = 0;
                int verify_b = 0;
                
                // if statement to verify A 
                if (variable_i == 0) {
                } else {
                    verify_a = (d[variable_i-1] - variable_a)%11;
                    if (verify_a >= 0) {
                    } else {
                        verify_a = negate(~verify_a+1,11);
                    }
                }

                // if statement to verify B             
                if (variable_j == 0) {
                } else {
                    verify_b = (d[variable_j-1] - variable_b)%11;
                    if (verify_b >= 0) {
                    } else {
                        verify_b = negate(~verify_b+1,11);
                    }
                }
                
               
                if(square_root != -1 && (variable_i != 0 && variable_j != 0) && (verify_a != 10 && verify_b != 10) )
                {
                    int[] temporary_out = new int[10];

                    // This while loop through the original BCH 10,6
                    int mag = 0;
                    while (mag < 10) {
                       // temporary file for it to verify after
                       temporary_out[mag] = d[mag];
                       
                       // This will fix error position for I with magnitude of A
                       if(mag == variable_i-1)
                       {
                            temporary_out[mag] = (temporary_out[mag] - variable_a)%11;
                           if (temporary_out[mag] >= 0) {
                           } else {
                               temporary_out[mag] = negate(~temporary_out[mag]+1,11);
                           }
                       }
                       
                        // This else statment will fix error position for J with magnitude of A
                       else if(mag == variable_j-1)
                       {
                            temporary_out[mag] = (temporary_out[mag] - variable_b)%11;
                           if (temporary_out[mag] >= 0) {
                           } else {
                               temporary_out[mag] = negate(~temporary_out[mag]+1,11);
                           }
                       }
                        mag++;
                    }
                    //print statements for the double error 
                    jTextArea1.setText("The input is:"+d[0]+d[1]+d[2]+d[3]+d[4]+d[5]+
                            " Please check:"+d[6]+d[7]+d[8]+d[9] + "\n"+
                            "The output is:"+temporary_out[0]+temporary_out[1]+temporary_out[2]+temporary_out[3]+temporary_out[4]+temporary_out[5]+temporary_out[6]+temporary_out[7]+temporary_out[8]+temporary_out[9]+
                            "\n This has a double_err(i=" + variable_i 
                                    + ",a="+variable_a+",j=" 
                                    + variable_j + ",b="
                                    + variable_b + ",syn("
                                    + syndrome[0] + "," 
                                    + syndrome[1] + ","
                                    + syndrome[2] + ","
                                    + syndrome[3] + "),"
                                    + "pqr(" + p + ","+ q + "," + r + ")");

                }
                else
                {
                    //print statements for the more than 2 
                    jTextArea1.setText("input:"+d[0]+d[1]+d[2]+d[3]+d[4]+d[5]+
                            " check:"+d[6]+d[7]+d[8]+d[9] + "\n"+
                            "output:???"+
                            "\nencoded syndromes: "+ e[0]+" "+e[1]+" "+e[2]+" "+e[3] +" "+"\n"+        
                            "decoded syndromes: "+ syndrome[0]+" "+syndrome[1]+" "+syndrome[2]+" "+syndrome[3]+" "+
                            "\nmorethan2_no_sqrt(syn("+syndrome[0]+","+syndrome[1]+","+syndrome[2]+","+syndrome[3]+") "+ "pqr("+p+","+q+","+r+"))");       
                }
            }
        }    
    }//GEN-LAST:event_jButton1MouseClicked

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        // TODO add your handling code here:
        clear_user_interface();
    }//GEN-LAST:event_jButton2ActionPerformed


    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Task2.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Task2.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Task2.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Task2.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>


        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Task2().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextField jTextField1;
    // End of variables declaration//GEN-END:variables
}
